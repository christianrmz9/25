{"ast":null,"code":"/**\r\n * Servicio para obtener datos del dashboard\r\n * \r\n * Este servicio actúa como una capa de abstracción entre los componentes\r\n * y la fuente de datos. Actualmente utiliza datos de ejemplo, pero está\r\n * diseñado para facilitar la transición a una API real en el futuro.\r\n */\n\nimport apiService from './apiService';\n\n// Estado para almacenar datos en caché\nconst cache = {\n  dashboardData: null,\n  lastFetched: null,\n  cacheTime: 5 * 60 * 1000 // 5 minutos (en milisegundos)\n};\n\n/**\r\n * Servicio para obtener y gestionar datos del dashboard\r\n */\nexport default {\n  /**\r\n   * Obtener todos los datos del dashboard en una sola llamada\r\n   * Implementa caché para evitar llamadas innecesarias\r\n   */\n  async getDashboardData() {\n    // Usar caché si los datos son recientes\n    if (cache.dashboardData && cache.lastFetched && Date.now() - cache.lastFetched < cache.cacheTime) {\n      console.log('Usando datos en caché del dashboard');\n      return Promise.resolve(cache.dashboardData);\n    }\n    try {\n      // En un entorno real, esta sería la URL de tu API\n      const response = await apiService.get('/dashboard/overview');\n\n      // Guardar en caché\n      cache.dashboardData = response.data;\n      cache.lastFetched = Date.now();\n      return response.data;\n    } catch (error) {\n      console.error('Error cargando datos del dashboard:', error);\n      throw error;\n    }\n  },\n  /**\r\n   * Forzar recarga de datos (ignorar caché)\r\n   */\n  async refreshDashboardData() {\n    try {\n      const response = await apiService.get('/dashboard/overview');\n\n      // Actualizar caché\n      cache.dashboardData = response.data;\n      cache.lastFetched = Date.now();\n      return response.data;\n    } catch (error) {\n      console.error('Error actualizando datos del dashboard:', error);\n      throw error;\n    }\n  },\n  /**\r\n   * Obtener una sección específica de datos\r\n   * @param {string} section - Nombre de la sección (ej: 'ventas', 'usuarios')\r\n   */\n  async getSectionData(section) {\n    try {\n      // Intentar obtener del caché primero\n      const allData = await this.getDashboardData();\n      return allData[section] || null;\n    } catch (error) {\n      console.error(`Error obteniendo datos de la sección ${section}:`, error);\n      throw error;\n    }\n  }\n};\n\n// Importar datos de ejemplo\nimport { dailySalesData, weeklySalesData, monthlySalesData, topProductsData, topCustomersData, salesByHourData, salesByDayData, salesByMonthData } from '../data/mockData';\n\n// Configuración del servicio\nconst API_BASE_URL = '/api'; // URL base para la API real (cuando se implemente)\nconst USE_MOCK_DATA = true; // Cambiar a false cuando se conecte a la API real\n\n/**\r\n * Obtiene las ventas del día actual\r\n * @returns {Promise<Object>} Datos de ventas diarias\r\n */\nexport async function getDailySales() {\n  if (USE_MOCK_DATA) {\n    // Simular un retraso de red para imitar una API real\n    await new Promise(resolve => setTimeout(resolve, 300));\n    return dailySalesData;\n  } else {\n    // Código para obtener datos de la API real\n    const response = await fetch(`${API_BASE_URL}/sales/daily`);\n    if (!response.ok) {\n      throw new Error('Error al obtener datos de ventas diarias');\n    }\n    return await response.json();\n  }\n}\n\n/**\r\n * Obtiene las ventas de la semana actual\r\n * @returns {Promise<Object>} Datos de ventas semanales\r\n */\nexport async function getWeeklySales() {\n  if (USE_MOCK_DATA) {\n    await new Promise(resolve => setTimeout(resolve, 300));\n    return weeklySalesData;\n  } else {\n    const response = await fetch(`${API_BASE_URL}/sales/weekly`);\n    if (!response.ok) {\n      throw new Error('Error al obtener datos de ventas semanales');\n    }\n    return await response.json();\n  }\n}\n\n/**\r\n * Obtiene las ventas del mes actual\r\n * @returns {Promise<Object>} Datos de ventas mensuales\r\n */\nexport async function getMonthlySales() {\n  if (USE_MOCK_DATA) {\n    await new Promise(resolve => setTimeout(resolve, 300));\n    return monthlySalesData;\n  } else {\n    const response = await fetch(`${API_BASE_URL}/sales/monthly`);\n    if (!response.ok) {\n      throw new Error('Error al obtener datos de ventas mensuales');\n    }\n    return await response.json();\n  }\n}\n\n/**\r\n * Obtiene los productos más vendidos\r\n * @param {number} limit - Número máximo de productos a obtener\r\n * @returns {Promise<Array>} Lista de productos más vendidos\r\n */\nexport async function getTopProducts(limit = 5) {\n  if (USE_MOCK_DATA) {\n    await new Promise(resolve => setTimeout(resolve, 300));\n    return topProductsData.slice(0, limit);\n  } else {\n    const response = await fetch(`${API_BASE_URL}/products/top?limit=${limit}`);\n    if (!response.ok) {\n      throw new Error('Error al obtener datos de productos más vendidos');\n    }\n    return await response.json();\n  }\n}\n\n/**\r\n * Obtiene los clientes principales\r\n * @param {number} limit - Número máximo de clientes a obtener\r\n * @returns {Promise<Array>} Lista de clientes principales\r\n */\nexport async function getTopCustomers(limit = 5) {\n  if (USE_MOCK_DATA) {\n    await new Promise(resolve => setTimeout(resolve, 300));\n    return topCustomersData.slice(0, limit);\n  } else {\n    const response = await fetch(`${API_BASE_URL}/customers/top?limit=${limit}`);\n    if (!response.ok) {\n      throw new Error('Error al obtener datos de clientes principales');\n    }\n    return await response.json();\n  }\n}\n\n/**\r\n * Obtiene las ventas por hora para el día actual\r\n * @returns {Promise<Array>} Datos de ventas por hora\r\n */\nexport async function getSalesByHour() {\n  if (USE_MOCK_DATA) {\n    await new Promise(resolve => setTimeout(resolve, 300));\n    return salesByHourData;\n  } else {\n    const response = await fetch(`${API_BASE_URL}/sales/by-hour`);\n    if (!response.ok) {\n      throw new Error('Error al obtener datos de ventas por hora');\n    }\n    return await response.json();\n  }\n}\n\n/**\r\n * Obtiene las ventas por día para la semana actual\r\n * @returns {Promise<Array>} Datos de ventas por día\r\n */\nexport async function getSalesByDay() {\n  if (USE_MOCK_DATA) {\n    await new Promise(resolve => setTimeout(resolve, 300));\n    return salesByDayData;\n  } else {\n    const response = await fetch(`${API_BASE_URL}/sales/by-day`);\n    if (!response.ok) {\n      throw new Error('Error al obtener datos de ventas por día');\n    }\n    return await response.json();\n  }\n}\n\n/**\r\n * Obtiene las ventas por mes para el año actual\r\n * @returns {Promise<Array>} Datos de ventas por mes\r\n */\nexport async function getSalesByMonth() {\n  if (USE_MOCK_DATA) {\n    await new Promise(resolve => setTimeout(resolve, 300));\n    return salesByMonthData;\n  } else {\n    const response = await fetch(`${API_BASE_URL}/sales/by-month`);\n    if (!response.ok) {\n      throw new Error('Error al obtener datos de ventas por mes');\n    }\n    return await response.json();\n  }\n}","map":{"version":3,"names":["apiService","cache","dashboardData","lastFetched","cacheTime","getDashboardData","Date","now","console","log","Promise","resolve","response","get","data","error","refreshDashboardData","getSectionData","section","allData","dailySalesData","weeklySalesData","monthlySalesData","topProductsData","topCustomersData","salesByHourData","salesByDayData","salesByMonthData","API_BASE_URL","USE_MOCK_DATA","getDailySales","setTimeout","fetch","ok","Error","json","getWeeklySales","getMonthlySales","getTopProducts","limit","slice","getTopCustomers","getSalesByHour","getSalesByDay","getSalesByMonth"],"sources":["C:/Users/Pc/Desktop/Proyectos/criwave/client/src/services/dashboardService.js"],"sourcesContent":["/**\r\n * Servicio para obtener datos del dashboard\r\n * \r\n * Este servicio actúa como una capa de abstracción entre los componentes\r\n * y la fuente de datos. Actualmente utiliza datos de ejemplo, pero está\r\n * diseñado para facilitar la transición a una API real en el futuro.\r\n */\r\n\r\nimport apiService from './apiService';\r\n\r\n// Estado para almacenar datos en caché\r\nconst cache = {\r\n  dashboardData: null,\r\n  lastFetched: null,\r\n  cacheTime: 5 * 60 * 1000 // 5 minutos (en milisegundos)\r\n};\r\n\r\n/**\r\n * Servicio para obtener y gestionar datos del dashboard\r\n */\r\nexport default {\r\n  /**\r\n   * Obtener todos los datos del dashboard en una sola llamada\r\n   * Implementa caché para evitar llamadas innecesarias\r\n   */\r\n  async getDashboardData() {\r\n    // Usar caché si los datos son recientes\r\n    if (cache.dashboardData && \r\n        cache.lastFetched && \r\n        (Date.now() - cache.lastFetched) < cache.cacheTime) {\r\n      console.log('Usando datos en caché del dashboard');\r\n      return Promise.resolve(cache.dashboardData);\r\n    }\r\n    \r\n    try {\r\n      // En un entorno real, esta sería la URL de tu API\r\n      const response = await apiService.get('/dashboard/overview');\r\n      \r\n      // Guardar en caché\r\n      cache.dashboardData = response.data;\r\n      cache.lastFetched = Date.now();\r\n      \r\n      return response.data;\r\n    } catch (error) {\r\n      console.error('Error cargando datos del dashboard:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Forzar recarga de datos (ignorar caché)\r\n   */\r\n  async refreshDashboardData() {\r\n    try {\r\n      const response = await apiService.get('/dashboard/overview');\r\n      \r\n      // Actualizar caché\r\n      cache.dashboardData = response.data;\r\n      cache.lastFetched = Date.now();\r\n      \r\n      return response.data;\r\n    } catch (error) {\r\n      console.error('Error actualizando datos del dashboard:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Obtener una sección específica de datos\r\n   * @param {string} section - Nombre de la sección (ej: 'ventas', 'usuarios')\r\n   */\r\n  async getSectionData(section) {\r\n    try {\r\n      // Intentar obtener del caché primero\r\n      const allData = await this.getDashboardData();\r\n      return allData[section] || null;\r\n    } catch (error) {\r\n      console.error(`Error obteniendo datos de la sección ${section}:`, error);\r\n      throw error;\r\n    }\r\n  }\r\n};\r\n\r\n// Importar datos de ejemplo\r\nimport {\r\n  dailySalesData,\r\n  weeklySalesData,\r\n  monthlySalesData,\r\n  topProductsData,\r\n  topCustomersData,\r\n  salesByHourData,\r\n  salesByDayData,\r\n  salesByMonthData\r\n} from '../data/mockData';\r\n\r\n// Configuración del servicio\r\nconst API_BASE_URL = '/api'; // URL base para la API real (cuando se implemente)\r\nconst USE_MOCK_DATA = true; // Cambiar a false cuando se conecte a la API real\r\n\r\n/**\r\n * Obtiene las ventas del día actual\r\n * @returns {Promise<Object>} Datos de ventas diarias\r\n */\r\nexport async function getDailySales() {\r\n  if (USE_MOCK_DATA) {\r\n    // Simular un retraso de red para imitar una API real\r\n    await new Promise(resolve => setTimeout(resolve, 300));\r\n    return dailySalesData;\r\n  } else {\r\n    // Código para obtener datos de la API real\r\n    const response = await fetch(`${API_BASE_URL}/sales/daily`);\r\n    if (!response.ok) {\r\n      throw new Error('Error al obtener datos de ventas diarias');\r\n    }\r\n    return await response.json();\r\n  }\r\n}\r\n\r\n/**\r\n * Obtiene las ventas de la semana actual\r\n * @returns {Promise<Object>} Datos de ventas semanales\r\n */\r\nexport async function getWeeklySales() {\r\n  if (USE_MOCK_DATA) {\r\n    await new Promise(resolve => setTimeout(resolve, 300));\r\n    return weeklySalesData;\r\n  } else {\r\n    const response = await fetch(`${API_BASE_URL}/sales/weekly`);\r\n    if (!response.ok) {\r\n      throw new Error('Error al obtener datos de ventas semanales');\r\n    }\r\n    return await response.json();\r\n  }\r\n}\r\n\r\n/**\r\n * Obtiene las ventas del mes actual\r\n * @returns {Promise<Object>} Datos de ventas mensuales\r\n */\r\nexport async function getMonthlySales() {\r\n  if (USE_MOCK_DATA) {\r\n    await new Promise(resolve => setTimeout(resolve, 300));\r\n    return monthlySalesData;\r\n  } else {\r\n    const response = await fetch(`${API_BASE_URL}/sales/monthly`);\r\n    if (!response.ok) {\r\n      throw new Error('Error al obtener datos de ventas mensuales');\r\n    }\r\n    return await response.json();\r\n  }\r\n}\r\n\r\n/**\r\n * Obtiene los productos más vendidos\r\n * @param {number} limit - Número máximo de productos a obtener\r\n * @returns {Promise<Array>} Lista de productos más vendidos\r\n */\r\nexport async function getTopProducts(limit = 5) {\r\n  if (USE_MOCK_DATA) {\r\n    await new Promise(resolve => setTimeout(resolve, 300));\r\n    return topProductsData.slice(0, limit);\r\n  } else {\r\n    const response = await fetch(`${API_BASE_URL}/products/top?limit=${limit}`);\r\n    if (!response.ok) {\r\n      throw new Error('Error al obtener datos de productos más vendidos');\r\n    }\r\n    return await response.json();\r\n  }\r\n}\r\n\r\n/**\r\n * Obtiene los clientes principales\r\n * @param {number} limit - Número máximo de clientes a obtener\r\n * @returns {Promise<Array>} Lista de clientes principales\r\n */\r\nexport async function getTopCustomers(limit = 5) {\r\n  if (USE_MOCK_DATA) {\r\n    await new Promise(resolve => setTimeout(resolve, 300));\r\n    return topCustomersData.slice(0, limit);\r\n  } else {\r\n    const response = await fetch(`${API_BASE_URL}/customers/top?limit=${limit}`);\r\n    if (!response.ok) {\r\n      throw new Error('Error al obtener datos de clientes principales');\r\n    }\r\n    return await response.json();\r\n  }\r\n}\r\n\r\n/**\r\n * Obtiene las ventas por hora para el día actual\r\n * @returns {Promise<Array>} Datos de ventas por hora\r\n */\r\nexport async function getSalesByHour() {\r\n  if (USE_MOCK_DATA) {\r\n    await new Promise(resolve => setTimeout(resolve, 300));\r\n    return salesByHourData;\r\n  } else {\r\n    const response = await fetch(`${API_BASE_URL}/sales/by-hour`);\r\n    if (!response.ok) {\r\n      throw new Error('Error al obtener datos de ventas por hora');\r\n    }\r\n    return await response.json();\r\n  }\r\n}\r\n\r\n/**\r\n * Obtiene las ventas por día para la semana actual\r\n * @returns {Promise<Array>} Datos de ventas por día\r\n */\r\nexport async function getSalesByDay() {\r\n  if (USE_MOCK_DATA) {\r\n    await new Promise(resolve => setTimeout(resolve, 300));\r\n    return salesByDayData;\r\n  } else {\r\n    const response = await fetch(`${API_BASE_URL}/sales/by-day`);\r\n    if (!response.ok) {\r\n      throw new Error('Error al obtener datos de ventas por día');\r\n    }\r\n    return await response.json();\r\n  }\r\n}\r\n\r\n/**\r\n * Obtiene las ventas por mes para el año actual\r\n * @returns {Promise<Array>} Datos de ventas por mes\r\n */\r\nexport async function getSalesByMonth() {\r\n  if (USE_MOCK_DATA) {\r\n    await new Promise(resolve => setTimeout(resolve, 300));\r\n    return salesByMonthData;\r\n  } else {\r\n    const response = await fetch(`${API_BASE_URL}/sales/by-month`);\r\n    if (!response.ok) {\r\n      throw new Error('Error al obtener datos de ventas por mes');\r\n    }\r\n    return await response.json();\r\n  }\r\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}