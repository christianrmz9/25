{"ast":null,"code":"import { ref, onMounted, onUnmounted, nextTick } from 'vue';\nimport dashboardService from '../services/dashboardService';\n\n/**\r\n * Composable para cargar y gestionar datos de gráficos\r\n * Incluye soporte para carga bajo demanda (cuando el elemento es visible)\r\n * \r\n * @param {String} dataType - Tipo de datos a cargar ('ventasDiarias', 'ventasSemanales', etc.)\r\n * @param {Object} options - Opciones adicionales\r\n * @returns {Object} - Datos y funciones para usar en el componente\r\n */\nexport function useChartData(dataType, options = {}) {\n  const {\n    loadOnVisible = true,\n    autoRefresh = false,\n    refreshInterval = 60000 // 1 minuto por defecto\n  } = options;\n  const chartData = ref(null);\n  const isLoading = ref(true);\n  const isVisible = ref(!loadOnVisible); // Si no cargamos al ser visible, asumimos que ya es visible\n  const error = ref(null);\n\n  // Referencias para IntersectionObserver\n  let observer = null;\n  let intervalId = null;\n\n  /**\r\n   * Cargar datos según el tipo especificado\r\n   */\n  const loadData = async () => {\n    // Solo cargar si el componente es visible o no usamos carga bajo demanda\n    if (!isVisible.value && loadOnVisible) return;\n    isLoading.value = true;\n    error.value = null;\n    try {\n      // Obtener datos del dashboard\n      const dashboardData = await dashboardService.getDashboardData();\n\n      // Extraer la sección de datos correcta según el tipo\n      switch (dataType) {\n        case 'ventasDiarias':\n          chartData.value = dashboardData.ventas?.diarias || [];\n          break;\n        case 'ventasSemanales':\n          chartData.value = dashboardData.ventas?.semanales || [];\n          break;\n        case 'ventasMensuales':\n          chartData.value = dashboardData.ventas?.mensuales || [];\n          break;\n        default:\n          // Si el tipo no coincide, intentar extraer directamente\n          chartData.value = dashboardData[dataType] || null;\n      }\n    } catch (err) {\n      console.error(`Error cargando datos para ${dataType}:`, err);\n      error.value = err.message || 'Error al cargar datos';\n    } finally {\n      isLoading.value = false;\n    }\n  };\n\n  /**\r\n   * Establecer el observador de intersección\r\n   */\n  const setupObserver = el => {\n    if (!el || !loadOnVisible) return;\n\n    // Crear nuevo observador\n    observer = new IntersectionObserver(entries => {\n      const isIntersecting = entries[0].isIntersecting;\n      if (isIntersecting && !isVisible.value) {\n        isVisible.value = true;\n        // Cargar datos cuando sea visible\n        nextTick(loadData);\n\n        // Detener observación si no necesitamos recargar\n        if (!autoRefresh) {\n          observer.disconnect();\n          observer = null;\n        }\n      }\n    }, {\n      threshold: 0.1 // 10% visible para activar\n    });\n\n    // Empezar a observar\n    observer.observe(el);\n  };\n\n  /**\r\n   * Configurar intervalo de actualización\r\n   */\n  const setupRefreshInterval = () => {\n    if (!autoRefresh || !refreshInterval) return;\n    intervalId = setInterval(() => {\n      if (isVisible.value) {\n        loadData();\n      }\n    }, refreshInterval);\n  };\n\n  /**\r\n   * Limpiar recursos al desmontar el componente\r\n   */\n  const cleanup = () => {\n    if (observer) {\n      observer.disconnect();\n      observer = null;\n    }\n    if (intervalId) {\n      clearInterval(intervalId);\n      intervalId = null;\n    }\n  };\n\n  // Configurar todo al montar el componente\n  onMounted(() => {\n    // Si no usamos carga bajo demanda, cargar inmediatamente\n    if (!loadOnVisible) {\n      loadData();\n    }\n\n    // Configurar intervalo de actualización si es necesario\n    if (autoRefresh) {\n      setupRefreshInterval();\n    }\n  });\n\n  // Limpiar recursos al desmontar\n  onUnmounted(cleanup);\n  return {\n    chartData,\n    isLoading,\n    isVisible,\n    error,\n    loadData,\n    setupObserver,\n    refresh: () => loadData() // Alias para recarga manual\n  };\n}","map":{"version":3,"names":["ref","onMounted","onUnmounted","nextTick","dashboardService","useChartData","dataType","options","loadOnVisible","autoRefresh","refreshInterval","chartData","isLoading","isVisible","error","observer","intervalId","loadData","value","dashboardData","getDashboardData","ventas","diarias","semanales","mensuales","err","console","message","setupObserver","el","IntersectionObserver","entries","isIntersecting","disconnect","threshold","observe","setupRefreshInterval","setInterval","cleanup","clearInterval","refresh"],"sources":["C:/Users/Pc/Desktop/Proyectos/criwave/client/src/composables/useChartData.js"],"sourcesContent":["import { ref, onMounted, onUnmounted, nextTick } from 'vue';\r\nimport dashboardService from '../services/dashboardService';\r\n\r\n/**\r\n * Composable para cargar y gestionar datos de gráficos\r\n * Incluye soporte para carga bajo demanda (cuando el elemento es visible)\r\n * \r\n * @param {String} dataType - Tipo de datos a cargar ('ventasDiarias', 'ventasSemanales', etc.)\r\n * @param {Object} options - Opciones adicionales\r\n * @returns {Object} - Datos y funciones para usar en el componente\r\n */\r\nexport function useChartData(dataType, options = {}) {\r\n  const {\r\n    loadOnVisible = true,\r\n    autoRefresh = false,\r\n    refreshInterval = 60000, // 1 minuto por defecto\r\n  } = options;\r\n  \r\n  const chartData = ref(null);\r\n  const isLoading = ref(true);\r\n  const isVisible = ref(!loadOnVisible); // Si no cargamos al ser visible, asumimos que ya es visible\r\n  const error = ref(null);\r\n  \r\n  // Referencias para IntersectionObserver\r\n  let observer = null;\r\n  let intervalId = null;\r\n  \r\n  /**\r\n   * Cargar datos según el tipo especificado\r\n   */\r\n  const loadData = async () => {\r\n    // Solo cargar si el componente es visible o no usamos carga bajo demanda\r\n    if (!isVisible.value && loadOnVisible) return;\r\n    \r\n    isLoading.value = true;\r\n    error.value = null;\r\n    \r\n    try {\r\n      // Obtener datos del dashboard\r\n      const dashboardData = await dashboardService.getDashboardData();\r\n      \r\n      // Extraer la sección de datos correcta según el tipo\r\n      switch (dataType) {\r\n        case 'ventasDiarias':\r\n          chartData.value = dashboardData.ventas?.diarias || [];\r\n          break;\r\n        case 'ventasSemanales':\r\n          chartData.value = dashboardData.ventas?.semanales || [];\r\n          break;\r\n        case 'ventasMensuales':\r\n          chartData.value = dashboardData.ventas?.mensuales || [];\r\n          break;\r\n        default:\r\n          // Si el tipo no coincide, intentar extraer directamente\r\n          chartData.value = dashboardData[dataType] || null;\r\n      }\r\n      \r\n    } catch (err) {\r\n      console.error(`Error cargando datos para ${dataType}:`, err);\r\n      error.value = err.message || 'Error al cargar datos';\r\n    } finally {\r\n      isLoading.value = false;\r\n    }\r\n  };\r\n  \r\n  /**\r\n   * Establecer el observador de intersección\r\n   */\r\n  const setupObserver = (el) => {\r\n    if (!el || !loadOnVisible) return;\r\n    \r\n    // Crear nuevo observador\r\n    observer = new IntersectionObserver((entries) => {\r\n      const isIntersecting = entries[0].isIntersecting;\r\n      \r\n      if (isIntersecting && !isVisible.value) {\r\n        isVisible.value = true;\r\n        // Cargar datos cuando sea visible\r\n        nextTick(loadData);\r\n        \r\n        // Detener observación si no necesitamos recargar\r\n        if (!autoRefresh) {\r\n          observer.disconnect();\r\n          observer = null;\r\n        }\r\n      }\r\n    }, {\r\n      threshold: 0.1 // 10% visible para activar\r\n    });\r\n    \r\n    // Empezar a observar\r\n    observer.observe(el);\r\n  };\r\n  \r\n  /**\r\n   * Configurar intervalo de actualización\r\n   */\r\n  const setupRefreshInterval = () => {\r\n    if (!autoRefresh || !refreshInterval) return;\r\n    \r\n    intervalId = setInterval(() => {\r\n      if (isVisible.value) {\r\n        loadData();\r\n      }\r\n    }, refreshInterval);\r\n  };\r\n  \r\n  /**\r\n   * Limpiar recursos al desmontar el componente\r\n   */\r\n  const cleanup = () => {\r\n    if (observer) {\r\n      observer.disconnect();\r\n      observer = null;\r\n    }\r\n    \r\n    if (intervalId) {\r\n      clearInterval(intervalId);\r\n      intervalId = null;\r\n    }\r\n  };\r\n  \r\n  // Configurar todo al montar el componente\r\n  onMounted(() => {\r\n    // Si no usamos carga bajo demanda, cargar inmediatamente\r\n    if (!loadOnVisible) {\r\n      loadData();\r\n    }\r\n    \r\n    // Configurar intervalo de actualización si es necesario\r\n    if (autoRefresh) {\r\n      setupRefreshInterval();\r\n    }\r\n  });\r\n  \r\n  // Limpiar recursos al desmontar\r\n  onUnmounted(cleanup);\r\n  \r\n  return {\r\n    chartData,\r\n    isLoading,\r\n    isVisible,\r\n    error,\r\n    loadData,\r\n    setupObserver,\r\n    refresh: () => loadData() // Alias para recarga manual\r\n  };\r\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}